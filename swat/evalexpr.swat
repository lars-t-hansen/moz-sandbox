;;; -*- mode: scheme -*-

(defmodule evalexpr

  (defclass Expr)

  (defconst+ UnNeg i32 0)
  (defconst+ UnNot i32 1)
  
  (defclass Unop (extends Expr)
    (op i32)
    (arg Expr))

  (defun+ (makeUnop (op i32) (arg Expr) -> Unop)
    (new Unop op arg))

  (defconst+ BinAdd i32 0)
  (defconst+ BinSub i32 1)
  (defconst+ BinAnd i32 2)
  (defconst+ BinOr  i32 3)
  
  (defclass Binop (extends Expr)
    (op i32)
    (arg1 Expr)
    (arg2 Expr))

  (defun+ (makeBinop (op i32) (arg1 Expr) (arg2 Expr) -> Binop)
    (new Binop op arg1 arg2))

  (defclass Let (extends Expr)
    (name Str)
    (val Expr)
    (body Expr))
  
  (defun+ (makeLet (name Str) (val Expr) (body Expr) -> Let)
    (new Let name val body))

  (defclass Number (extends Expr)
    (val i32))

  (defun+ (makeNumber (n i32) -> Number)
    (new Number n))

  (defclass Id (extends Expr)
    (name Str))

  (defun+ (makeId (name Str) -> Id)
    (new Id name))

  (defvirtual (eval (self Expr) (e Env) -> i32)
    (Unop   evalUnop)
    (Binop  evalBinop)
    (Let    evalLet)
    (Number evalNumber)
    (Id     evalId))

  (defclass Env
    (name Str)
    (val  i32)
    (next Env))

  (defun (make-env -> Env)
    (null Env))

  (defun (extend (e Env) (name Str) (val i32) -> Env)
    (new Env name val e))

  (defun (lookup (e Env) (name Str) -> Env)
    (if (or (null? e) (str=? (*name e) name))
	e
	(lookup (*next e) name)))
	    
  (defclass Str
    (name i32))				; No strings yet

  (defun+ (makeStr (name i32) -> Str)
    (new Str name))

  (defun (str=? (a Str) (b Str) -> i32)
    (= (*name a) (*name b)))

  (defun (evalUnop (self Unop) (e Env) -> i32)
    (let ((v (eval (*arg self) e)))
      (case (*op self)
	((UnNeg) (- 0 v))
	((UnNot) (bitnot v))
	(else (trap i32)))))

  (defun (evalBinop (self Binop) (e Env) -> i32)
    (let ((v1 (eval (*arg1 self) e)))
      (let ((v2 (eval (*arg2 self) e)))
	(case (*op self)
	  ((BinAdd) (+ v1 v2))
	  ((BinSub) (- v1 v2))
	  ((BinAnd) (bitand v1 v2))
	  ((BinOr)  (bitor v1 v2))
	  (else (trap i32))))))

  (defun (evalNumber (self Number) (e Env) -> i32)
    (*val self))

  (defun (evalId (self Id) (e Env) -> i32)
    (let ((binding (lookup e (*name self))))
      (if (null? binding)
	  (trap i32)
	  (*val binding))))

  (defun (evalLet (self Let) (e Env) -> i32)
    (let ((v (eval (*val self) e)))
      (eval (*body self) (extend e (*name self) v))))

  (defun+ (evalExpr (expr Expr) -> i32)
    (eval expr (make-env)))

)

(js "
var i = new WebAssembly.Instance(evalexpr.module, {lib: evalexpr.lib}).exports;
assertEq(i.evalExpr(i.makeBinop(i.BinAdd, i.makeNumber(3), i.makeNumber(4))), 7);
")
